/*
-----------------------------------------------------------------------------
Filename:    OgreVishesh.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC10 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/

#include "../include/OgreVishesh.h"
#include<iostream>
using namespace std;

OgreVisheshFrameListener:: OgreVisheshFrameListener(Ogre::SceneNode* node,Ogre:: RenderWindow* win,Ogre::Camera* cam,Ogre::Entity* ent)
{
  size_t windowHnd = 0;
	stringstream windowHndStr;
	OIS::ParamList pl;
	
	_walkingSpeed=50.0;
	_rotation=0;
	_node=node;
	_cam=cam;
	_entity=ent;
	_aniState= _entity->getAnimationState("RunBase");
	_aniState->setLoop(false);
	_aniStateTop=_entity->getAnimationState("RunTop");
	_aniStateTop->setLoop(false);
	win->getCustomAttribute("WINDOW",&windowHnd);
	windowHndStr << windowHnd;
	_polyMode =Ogre::PolygonMode::PM_SOLID;
	_timer.reset();
	pl.insert(make_pair(string("WINDOW"),windowHndStr.str()));
	_man= OIS::InputManager::createInputSystem(pl);
	_key=static_cast<OIS::Keyboard*>(_man->createInputObject(OIS::OISKeyboard,false));
	_mouse=static_cast<OIS::Mouse*>(_man->createInputObject(OIS::OISMouse,false));
} 

OgreVisheshFrameListener:: OgreVisheshFrameListener(void)
{
	FrameListener = NULL;
}

OgreVisheshFrameListener::~ OgreVisheshFrameListener(void)
{
	if(FrameListener)
	{
		delete FrameListener;
		_man->destroyInputObject(_key);
		_man->destroyInputObject(_mouse);
		OIS::InputManager::destroyInputSystem(_man);
	}	
}

bool OgreVisheshFrameListener::frameStarted(const Ogre:: FrameEvent &evt)
{
	//_node->translate(Ogre::Vector3(0.1,0,0));//1000,0,0) * evt.timeSinceLastEvent);
	Ogre::Vector3 translate(0,0,0),SinbadTranslate(0,0,0);
	static float speed=1;
	bool walked=0;
	_key->capture();
	_mouse->capture();
	if(_key->isKeyDown(OIS::KC_ESCAPE))
		return false;

	if(_key->isKeyDown(OIS::KC_W))
		translate+=Ogre::Vector3(0,0,-0.1);
	else if(_key->isKeyDown(OIS::KC_A))
		translate+=Ogre::Vector3(-0.1,0,0);
	else if(_key->isKeyDown(OIS::KC_D))
		translate+=Ogre::Vector3(0.1,0,0);
	else if(_key->isKeyDown(OIS::KC_S))
		translate+=Ogre::Vector3(0,0,0.1);
	else if(_key->isKeyDown(OIS::KC_R) && _timer.getMilliseconds()>250)
	{
		_timer.reset();
		if(_polyMode==Ogre::PM_SOLID)
			_polyMode=Ogre::PolygonMode::PM_WIREFRAME;
		else if(_polyMode==Ogre::PM_WIREFRAME)
			_polyMode=Ogre::PolygonMode::PM_POINTS;
		else if(_polyMode==Ogre::PM_POINTS)
			_polyMode=Ogre::PolygonMode::PM_SOLID;
	}
	else if(_key->isKeyDown(OIS::KC_Z))
		speed+=0.03;
	else if(_key->isKeyDown(OIS::KC_X))
		speed-=0.03;
	else if(_key->isKeyDown(OIS::KC_UP))
	{
		SinbadTranslate+=Ogre::Vector3(0,0,-1);
		_rotation=3.14;
		walked=1;
	}
	else if(_key->isKeyDown(OIS::KC_DOWN))
	{
		SinbadTranslate+=Ogre::Vector3(0,0,1);
		_rotation=0;
		walked=1;
	}
	else if(_key->isKeyDown(OIS::KC_LEFT))
	{
		SinbadTranslate+=Ogre::Vector3(-1,0,0);
		_rotation=-1.57;
		walked=1;
	}
	else if(_key->isKeyDown(OIS::KC_RIGHT))
	{
		SinbadTranslate+=Ogre::Vector3(1,0,0);
		_rotation=1.57;
		walked=1;
	}

	float rotX=_mouse->getMouseState().X.rel*-1;
	float rotY=_mouse->getMouseState().Y.rel*-1;

	_cam->yaw(Ogre::Radian(rotX*0.1));
	_cam->pitch(Ogre::Radian(rotY*0.1));
	_cam->moveRelative(translate);
	_cam->setPolygonMode(_polyMode);
	
	_aniState->addTime(evt.timeSinceLastFrame*speed);
	_aniStateTop->addTime(evt.timeSinceLastFrame*speed);

	if(walked)
	{
		_aniState->setEnabled(true);
		_aniStateTop->setEnabled(true);
		if(_aniState->hasEnded())
			_aniState->setTimePosition(0);
		if(_aniStateTop->hasEnded())
			_aniStateTop->setTimePosition(0);
	}
	else
	{
		_aniState->setEnabled(false);
		_aniStateTop->setEnabled(false);
		_aniState->setTimePosition(0);
		_aniStateTop->setTimePosition(0);
	}

	_node->translate(SinbadTranslate*speed);
	_node->resetOrientation();
	_node->yaw(Ogre::Radian(_rotation));

	return true;
}


//-------------------------------------------------------------------------------------
OgreVishesh::OgreVishesh(void)
{
}
//-------------------------------------------------------------------------------------
OgreVishesh::~OgreVishesh(void)
{
}

void OgreVishesh::createFrameListener(void)
{
	Ogre::FrameListener *FrameListener=new OgreVisheshFrameListener(_SinbadNode,mWindow,mCamera,_SinbadEnt);
	mRoot->addFrameListener(FrameListener);
}

void OgreVishesh::createCamera(void)
{
	mCamera= mSceneMgr->createCamera("MyCam");
    mCamera->setPosition(0,100,200);
	mCamera->lookAt(0,0,0);
	mCamera->setNearClipDistance(5);
	mCameraMan = new OgreBites::SdkCameraMan(mCamera);	
}

//-------------------------------------------------------------------------------------
void OgreVishesh::createScene(void)
{
	Ogre::Plane plane(Ogre::Vector3::UNIT_Y,-10);
	Ogre::MeshManager::getSingleton().createPlane("plane",Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,plane,
													1500,1500,20,20,true,1,5,5,Ogre::Vector3::UNIT_Z);
	Ogre::Entity* ent1=mSceneMgr->createEntity("LightPlaneEntity","plane");
	Ogre::Entity* swrd1=mSceneMgr->createEntity("swrd1","Sword.mesh");
	Ogre::Entity* swrd2=mSceneMgr->createEntity("swrd2","Sword.mesh");
	mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(ent1);
	ent1->setMaterialName("Examples/BeachStones");

	Ogre::Light* light1=mSceneMgr->createLight("Light1");
	light1->setType(Ogre::Light::LT_DIRECTIONAL);
	light1->setDirection(Ogre::Vector3(1,-1,0));

	 Ogre::SceneNode* node1=mSceneMgr->createSceneNode("node1");
	 mSceneMgr->getRootSceneNode()->addChild(node1);
	 //Ogre::Entity* sinbad = mSceneMgr->createEntity("sinbad", "Sinbad.mesh");
	 _SinbadEnt=mSceneMgr->createEntity("sinbad", "Sinbad.mesh");
	 _SinbadEnt->attachObjectToBone("Handle.L",swrd1);
	 _SinbadEnt->attachObjectToBone("Handle.R",swrd2);
	 _SinbadNode = node1->createChildSceneNode("sinbadnode",Ogre::Vector3(0,4,0));
	 _SinbadNode->setScale(3,3,3);
	 _SinbadNode->attachObject(_SinbadEnt);

	 mSceneMgr->setShadowTechnique((Ogre::SHADOWTYPE_STENCIL_ADDITIVE));

	 std::cout<<"VISHESH";
}



#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        OgreVishesh app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
